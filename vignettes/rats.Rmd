---
title: "Rats: from WinBUGS model to DAGnabit nodes and edges"
date: "`r format(Sys.Date())`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{rats}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE, comment = "#>",
  fig.width = 7, fig.height = 4.8,
  message = FALSE, warning = FALSE
)

suppressPackageStartupMessages({
  library(knitr)
  library(dplyr)
  library(readr)
})

# we will use this package name for system.file() lookups
pkg <- "dagnabit.docs"

# Make paths relative to the repo root while developing
if (requireNamespace("here", quietly = TRUE)) {
  knitr::opts_knit$set(root.dir = here::here())
}

```
---

### Overview

The Rats example is a classic hierarchical normal model for longitudinal growth taken from section 6 of Gelfand et al. (1990) and used in the WinBUGS documentation. 

Thirty young rats are weighed weekly for five weeks. Each rat i has its own intercept alpha[i] and slope beta[i], describing a random effects linear growth curve in time x[j], with time centered at xbar = 22. Y[i,j] is the weight of each rat i on day x[j]. These rat-specific parameters are drawn from population-level normals with means alpha.c and beta.c and precisions tau.alpha and tau.beta. Measurement noise is shared across rats with precision.

This vignette shows diagram extraction for Rats: 

  - Show the original WinBUGS model code for Rats.
  
  - Show the official WinBUGS graphical diagram for that model.
  
  - Use the **parser**, via parse_bugs_to_nodes_edges(), to turn the BUGS text into nodes and edges tables.
  
  - Verify those tables against the packaged CSV fixtures for Rats.
  
  - Add the diagram from the **layout editor** (which mirrors the official WinBUGS diagram).

The goal is to demonstrate how DAGnabit recreates the WinBUGS graph directly from model code.

### A) Original WinBUGS model code

The model below matches the rats example from the WinBUGS help file (“Rats: a normal hierarchical model”). We keep it inside an R string so the same text can be passed straight to the parser.

```{r rats-code, include=FALSE}
model_code <- "
model
{
  for (i in 1:N) {
    for (j in 1:T) {
      Y[i,j] ~ dnorm(mu[i,j], tau.c)
      mu[i,j] <- alpha[i] + beta[i] * (x[j] - xbar)
    }
    alpha[i] ~ dnorm(alpha.c, tau.alpha)
    beta[i]  ~ dnorm(beta.c,  tau.beta)
  }

  # observation precision and SD
  tau.c  ~ dgamma(0.001, 0.001)
  sigma  <- 1 / sqrt(tau.c)

  # population means
  alpha.c ~ dnorm(0.0, 1.0E-6)
  beta.c  ~ dnorm(0.0, 1.0E-6)

  # ---- Choice of prior for random-effects variances ----
  # Prior 1 (WinBUGS text): uniform on SD
  sigma.alpha ~ dunif(0, 100)
  sigma.beta  ~ dunif(0, 100)
  tau.alpha   <- 1 / (sigma.alpha * sigma.alpha)
  tau.beta    <- 1 / (sigma.beta  * sigma.beta)

  # Prior 2 (not recommended in the text):
  # tau.alpha ~ dgamma(0.001, 0.001)
  # tau.beta  ~ dgamma(0.001, 0.001)

  # derived intercept at x = 0 when centering at xbar
  alpha0 <- alpha.c - xbar * beta.c
}
"
```
```{r rats-codee}
cat(model_code) 
```

This is the text that the parser will turn into a DAG (Directed Acyclic Graph) representation.


### B) Official WinBUGS diagram

The figure below is taken from the WinBUGS documentation and shows the
graphical model that our package is trying to reproduce. This is a reference diagram for the Rats model taken from the 'WinBUGS help examples' pdf.

```{r rats-diagram, echo=FALSE, fig.cap="Official WinBUGS 'Rats' graphical model",out.width="80%", fig.align="center"}
paths <- c(
  system.file("extdata/winbugs/rats_diagram.png", package = "dagnabit.docs"),
  "inst/extdata/winbugs/rats_diagram.png",
  "../inst/extdata/winbugs/rats_diagram.png",
  "../../inst/extdata/winbugs/rats_diagram.png"
)
paths <- paths[nzchar(paths)]
img <- paths[which(file.exists(paths))[1]]
if (!length(img)) {
  cat("Diagram not found. Add inst/extdata/winbugs/rats_diagram.png and re-knit.\n")
} else {
  knitr::include_graphics(img)
}
```

The diagram shows:

  - An outer plate over rats i = 1,…,N for alpha[i] and beta[i]. Fitted parameter nodes for alpha[i] and beta[i].
  
  - An inner plate over time points j = 1,…,T for the observations Y[i,j]. Data nodes for observed weights Y[i,j].
  
  - Hyperparameter nodes for alpha.c, beta.c, sigma.alpha, and sigma.beta
living outside the plates.

   - Arrows indicating conditional dependencies.


The goal is for the DAGnabit nodes/edges tables to encode exactly this structure and reconstruct it from the BUGS code.


### C) BUGS parser → tidy nodes/edges

To extract the diagram, the function `parse_bugs_to_nodes_edges()` is used. 
'parse_bugs_to_nodes_edges(model_code)' returns a named list with components 'nodes' and 'edges'.

This function takes the BUGS model code as a single string and outputs two tidy tables to describe the graph:

  - Nodes: one row per node (parameters, data, hyperparameters, etc.)

  - Edges: all directed relationships between nodes (one row per arrow)
  

The usage is deliberately simple:

  - Put your BUGS model into model_code

  - Call the parser with model_code

  - Work with the returned nodes and edges data frames


```{r rats-parser}
setwd("~/dagnabit.docs") 
source("FinalParserFunc6.0")

rats_parsed <- parse_bugs_to_nodes_edges(model_code)

str(rats_parsed, max.level = 1)

rats_nodes <- rats_parsed$nodes
rats_edges <- rats_parsed$edges

list(
number_of_nodes = nrow(rats_nodes),
number_of_edges = nrow(rats_edges)
)
```

The parser walks through the Rats BUGS code and:

  - identifies variables such as alpha[i], beta[i], mu[i,j], Y[i,j], etc.;

  - classifies them (as data, parameters, ...);

  - records which nodes depend on which (e.g. edges from alpha[i] and beta[i] into mu[i,j]);

  - and keeps track of plates such as for (i in 1:N) and for (j in 1:T).


The nodes table describes what is in the diagram, while the edges table describes how those things are connected.

```{r rats-parser-peek, results='asis'}
knitr::kable(
head(rats_nodes, 19),
caption = "Rows of the Rats nodes table returned by the parser."
)

knitr::kable(
head(rats_edges, 16),
caption = "Rows of the Rats edges table returned by the parser."
)
```

The nodes table encodes each graphical node in the WinBUGS diagram (e.g. alpha[i], beta[i], mu[i,j], Y[i,j], tau.c, sigma, alpha0), including its label, type, and plate information.

The edges table records directed connections, such as alpha.c → alpha[i], beta[i] → mu[i,j], and mu[i,j] → Y[i,j]. It includes from and to columns (which have the node labels), and the kind column (stochastic or deterministic connection).


### D) Nodes & edges fixtures (cross-check)

The package ships reference CSV files for the Rats example that live under inst/extdata/examples/rats/nodes.csv and inst/extdata/examples/rats/edges.csv. This part loads those CSVs verifies they match the current parser output, and prints out a small excerpt for reference.

For reproducibility, the dagnabit.docs package includes CSV fixtures for
the Rats example. Users of the vignette do not need to worry about these files, but they are useful for checking that the current parser output still matches our agreed representation.

```{r rats-fixtures, message=FALSE, warning=FALSE}
nodes_path <- "inst/extdata/examples/rats/nodes.csv"
edges_path <- "inst/extdata/examples/rats/edges.csv"

if (!file.exists(nodes_path) || !file.exists(edges_path)) {
  cat(
    "Rats fixture CSVs not found in inst/extdata/examples/rats/.\n",
    "This vignette will still knit, but the fixture cross-check is skipped.\n"
  )
} else {
  rats_nodes_fixture <- readr::read_csv(nodes_path, show_col_types = FALSE)
  rats_edges_fixture <- readr::read_csv(edges_path, show_col_types = FALSE)

  list(
    fixture_nodes = nrow(rats_nodes_fixture),
    fixture_edges = nrow(rats_edges_fixture)
  )
}
```

We can see that the number of nodes and edges in the reference CSV files matches the number of nodes and edges we get from the BUGS parser.


### E) Layout editor (interactive + export)

The goal of the DAGnabit layout editor is to allow users to refine automatically generated diagrams from nodes and edges tables into a polished and human-readable graphical model that mirrors the WinBUGS. While the parser produces correct dependency information, the visual arrangement of nodes requires human judgment. The layout editor provides that final editorial step.

We feed rats_nodes and rats_edges into the layout editor widget. When the widget first loads, it produces a random force-directed layout. This algorithm is one of the foundational visualization techniques in network analysis:

  - Nodes behave like positively charged particles that repel one another.

  - Edges act like springs pulling related nodes together.

  - The browser iteratively simulates these physical forces until the graph stabilizes.

This ensures a diagram where nodes are not stacked on top of each other, but no semantics or human readability are enforced. It is simply the computer’s best guess at spreading things out.

Initial layout screenshot:
```{r rats-layout-initial, echo=FALSE, fig.cap="Initial force-directed layout for the Rats example.", out.width="80%", fig.align="center"}
paths <- c(
  system.file("extdata/examples/rats/rats_layout_initial.png", package = pkg),
  "inst/extdata/examples/rats/rats_layout_initial.png",
  "../inst/extdata/examples/rats/rats_layout_initial.png",
  "vignettes/rats_layout_initial.png"
)

paths <- paths[nzchar(paths)]
img <- paths[file.exists(paths)][1]

if (length(img) && !is.na(img)) {
  knitr::include_graphics(img)
} else {
  cat("Initial Rats layout PNG not found. Add rats_layout_initial.png to inst/extdata/examples/rats/ and re-knit.\n")
}
```

Then, we drag nodes around until the diagram matches the official Rats picture. This is what it looks like after arranging the graph

After the initial layout appears, the user can drag nodes manually to create a clean diagram. This step is essential since graphical models are explanatory tools, and human editorial judgment is required to:

  - organize plates so they visually match the BUGS diagram, 
  
  - align hyperparameters at the top,
  
  - clarify conditional dependencies.
  
Final layout screenshot: 
```{r rats-layout-final, echo=FALSE, fig.cap="Manually edited layout for the Rats example (matching the WinBUGS diagram).", out.width="80%", fig.align="center"}
paths <- c(
  system.file("extdata/examples/rats/rats_layout_final.png", package = pkg),
  "inst/extdata/examples/rats/rats_layout_final.png",
  "../inst/extdata/examples/rats/rats_layout_final.png",
  "vignettes/rats_layout_final.png"
)

paths <- paths[nzchar(paths)]
img <- paths[file.exists(paths)][1]

if (length(img) && !is.na(img)) {
  knitr::include_graphics(img)
} else {
  cat("Final Rats layout PNG not found. Add ratss_layout_final.png to inst/extdata/examples/rats/ and re-knit.\n")
}
```

We export a PNG and store it under inst/extdata/examples/rats/rats_layout.png. Once exported, that PNG can be included in other documentation or compared visually to the WinBUGS reference.

The widget is not just an R visualization; it is powered by client-side JavaScript, executed directly in the user’s browser. This is a major modern capability. JavaScript is extremely fast in today’s browsers. It handles real-time dragging, force-simulation physics, and dynamic edge routing. No server interaction is needed and all layout computation happens locally. This separation lets R handle the statistical structure while JavaScript handles the interactive geometry.

This combination of R + JavaScript enables DAGnabit to provide:

  - a fully interactive graph editor

  - reproducible diagrams

  - editable layouts that can be exported and reused

The layout editor is a key component of the package, bridging computational parsing and human-driven communication.
