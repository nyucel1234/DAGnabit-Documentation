---
title: "Pumps: gamma–Poisson hierarchical model"
date: "`r format(Sys.Date())`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{pumps}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE, comment = "#>",
  fig.width = 7, fig.height = 4.8,
  message = FALSE, warning = FALSE
)

suppressPackageStartupMessages({
  library(knitr)
  library(dplyr)
  library(readr)
})

pkg <- "dagnabit.docs"

if (requireNamespace("here", quietly = TRUE)) {
  knitr::opts_knit$set(root.dir = here::here())
}

```


### Overview

The Pumps example (George et al. 1993) is a classic Bayesian  model for rates of failure in 10 nuclear power plant pumps using a hierarchical Gamma–Poisson setup that naturally accounts for differing exposure times.

Each pump’s observed number of failures (x[i]) follow a Poisson distribution with mean (lambda[i]) = (theta[i]) * (t[i]), where (theta[i]) is the failure rate for each pump i and (t[i]) is the length of exposure time of the pump (in thousands of hours). 

The model assumes:

  - x[i] ~ Poisson(lambda[i])
  - theta[i] ~ Gamma(alpha,beta)
  
The hyperparameters have priors:

  - alpha ~ Exponential(1.0) 
  - beta ~ Gamma(0.1, 1.0)
  

This vignette shows diagram extraction for Pumps: 

  - Show the original WinBUGS model code for Pumps.
  
  - Show the official WinBUGS graphical diagram for that model.
  
  - Use the **parser**, via parse_bugs_to_nodes_edges(), to turn the BUGS text into nodes and edges tables.
  
  - Verify those tables against the packaged CSV fixtures for Pumps.
  
  - Add the diagram from the **layout editor** (which mirrors the official WinBUGS diagram).

The goal is to demonstrate how DAGnabit recreates the WinBUGS graph directly from model code.


### A) Original BUGS model

The model below matches the pumps example from the WinBUGS help file (“Pumps: conjugate gamma-Poisson hierarchical model”). We keep it inside an R string so the same text can be passed straight to the parser.

```{r pumps-code, include=FALSE}
model_code <- "
model 
{
  for (i in 1:N) {
    theta[i]  ~ dgamma(alpha, beta)
    lambda[i] <- theta[i] * t[i]
    x[i]      ~ dpois(lambda[i])
  }
  alpha ~ dexp(1)
  beta  ~ dgamma(0.1, 1.0)
}
"
```
```{r pumps-codee}
cat(model_code) 
```

This is the text that the parser will turn into a DAG (Directed Acyclic Graph) representation.


### B) Official WinBUGS diagram

The figure below is taken from the WinBUGS documentation and shows the
graphical model that our package is trying to reproduce. This is a reference diagram for the Pumps model taken from the 'WinBUGS help examples' pdf.

```{r pumps-diagram, echo=FALSE, fig.cap="Official WinBUGS 'Pumps' graphical model"}
paths <- c(
system.file("extdata/winbugs/pumps_diagram.png", package = "dagnabit.docs"),
"inst/extdata/winbugs/pumps_diagram.png",
"../inst/extdata/winbugs/pumps_diagram.png",
"../../inst/extdata/winbugs/pumps_diagram.png"
)
paths <- paths[nzchar(paths)]
img <- paths[which(file.exists(paths))[1]]
if (!length(img)) {
cat("Diagram not found. Add inst/extdata/winbugs/pumps_diagram.png and re-knit.\n")
} else {
knitr::include_graphics(img)
}
```

The diagram shows:

  - A single plate over pumps i = 1,…,N with the latent failure rate theta[i] for pump i, the mean of the Poisson distribution for failures lambda[i], the observed number of failures x[i] for each pump, and known exposure time t[i].
  
      - Each theta[i] feeds into lambda[i] together with the known exposure time t[i] (data node), and lambda[i] in turn feeds into x[i].
  
  - Outside the plate, hyperparameter nodes alpha and beta governing the Gamma prior on each theta[i]. They are drawn outside the plate since they are shared across all pumps.


The goal is for the DAGnabit nodes/edges tables to encode exactly this structure and reconstruct it from the BUGS code.



### C) BUGS parser → tidy nodes/edges

To extract the diagram, the function `parse_bugs_to_nodes_edges()` is used. 
'parse_bugs_to_nodes_edges(model_code)' returns a named list with components 'nodes' and 'edges'.

This function takes the BUGS model code as a single string and outputs two tidy tables to describe the graph:

  - Nodes: one row per node (parameters, data, hyperparameters, etc.)

  - Edges: all directed relationships between nodes (one row per arrow)
  

The usage is deliberately simple:

  - Put your BUGS model into model_code

  - Call the parser with model_code

  - Work with the returned nodes and edges data frames


```{r rats-parser, message=FALSE, warning=FALSE}
setwd("~/dagnabit.docs") 
source("FinalParserFunc6.0")

pumps_parsed <- parse_bugs_to_nodes_edges(model_code)

str(pumps_parsed, max.level = 1)

pumps_nodes <- pumps_parsed$nodes
pumps_edges <- pumps_parsed$edges

list(
number_of_nodes = nrow(pumps_nodes),
number_of_edges = nrow(pumps_edges)
)
```

The parser walks through the Pumps BUGS code and:

  - identifies variables (alpha, beta, theta[i], t[i], lambda[i], x[i]));

  - classifies them (as data, parameters, ...);

  - records which nodes depend on which;

  - and keeps track of the plate such as for (i in 1:N).


The nodes table describes what is in the diagram, while the edges table describes how those things are connected.

```{r pumps-parser-peek, results='asis'}
knitr::kable(
head(pumps_nodes, 9),
caption = "Rows of the Pumps nodes table returned by the parser."
)

knitr::kable(
head(pumps_edges, 5),
caption = "Rows of the Pumps edges table returned by the parser."
)
```

The nodes table encodes each graphical node in the WinBUGS diagram (e.g. theta[i], lamdba[i], alpha, ...), including its label, type, and plate information.

The edges table records directed connections, such as alpha → theta[i], lambda[i] → x[i], and beta → theta[i]. It includes from and to columns (which have the node labels), and the kind column (stochastic or deterministic connection).


### D) Nodes & edges fixtures (cross-check)

The package ships reference CSV files for the Pumps example that live under inst/extdata/examples/pumps/nodes.csv and inst/extdata/examples/pumps/edges.csv. This part loads those CSVs verifies they match the current parser output, and prints out a small excerpt for reference.

For reproducibility, the dagnabit.docs package includes CSV fixtures for
the Pumps example. Users of the vignette do not need to worry about these files, but they are useful for checking that the current parser output still matches our agreed representation.

```{r pumps-fixtures, message=FALSE, warning=FALSE}
nodes_path <- "inst/extdata/examples/pumps/nodes.csv"
edges_path <- "inst/extdata/examples/pumps/edges.csv"

if (!file.exists(nodes_path) || !file.exists(edges_path)) {
cat(
"Pumps fixture CSVs not found in inst/extdata/examples/pumps/.\n",
"This vignette will still knit, but the fixture cross-check is skipped.\n"
)
} else {
pumps_nodes_fixture <- readr::read_csv(nodes_path, show_col_types = FALSE)
pumps_edges_fixture <- readr::read_csv(edges_path, show_col_types = FALSE)

list(
fixture_nodes = nrow(pumps_nodes_fixture),
fixture_edges = nrow(pumps_edges_fixture)
)
}
```


### E) Layout editor (interactive + export)

The goal of the DAGnabit layout editor is to allow users to refine automatically generated diagrams from nodes and edges tables into a polished and human-readable graphical model that mirrors the WinBUGS. While the parser produces correct dependency information, the visual arrangement of nodes requires human judgment. The layout editor provides that final editorial step.

We feed pumps_nodes and pumps_edges into the layout editor widget. When the widget first loads, it produces a random force-directed layout. This algorithm is one of the foundational visualization techniques in network analysis:

  - Nodes behave like positively charged particles that repel one another.

  - Edges act like springs pulling related nodes together.

  - The browser iteratively simulates these physical forces until the graph stabilizes.

This ensures a diagram where nodes are not stacked on top of each other, but no semantics or human readability are enforced. It is simply the computer’s best guess at spreading things out.

Initial layout screenshot:
```{r pumps-layout-initial, echo=FALSE, fig.cap="Initial force-directed layout for the Pumps example.", out.width="80%", fig.align="center"}
paths <- c(
  system.file("extdata/examples/pumps/pumps_layout_initial.png", package = pkg),
  "inst/extdata/examples/pumps/pumps_layout_initial.png",
  "../inst/extdata/examples/pumps/pumps_layout_initial.png",
  "vignettes/pumps_layout_initial.png"
)

paths <- paths[nzchar(paths)]
img <- paths[file.exists(paths)][1]

if (length(img) && !is.na(img)) {
  knitr::include_graphics(img)
} else {
  cat("Initial Pumps layout PNG not found. Add pumps_layout_initial.png to inst/extdata/examples/pumps/ and re-knit.\n")
}
```

Then, we drag nodes around until the diagram matches the official Pumps picture. This is what it looks like after arranging the graph

After the initial layout appears, the user can drag nodes manually to create a clean diagram. This step is essential since graphical models are explanatory tools, and human editorial judgment is required to:

  - organize plates so they visually match the BUGS diagram, 
  
  - align hyperparameters at the top,
  
  - clarify conditional dependencies.
  
Final layout screenshot: 
```{r pumps-layout-final, echo=FALSE, fig.cap="Manually edited layout for the Pumps example (matching the WinBUGS diagram).", out.width="80%", fig.align="center"}
paths <- c(
  system.file("extdata/examples/pumps/pumps_layout_final.png", package = pkg),
  "inst/extdata/examples/pumps/pumps_layout_final.png",
  "../inst/extdata/examples/pumps/pumps_layout_final.png",
  "vignettes/pumps_layout_final.png"
)

paths <- paths[nzchar(paths)]
img <- paths[file.exists(paths)][1]

if (length(img) && !is.na(img)) {
  knitr::include_graphics(img)
} else {
  cat("Final Pumps layout PNG not found. Add pumps_layout_final.png to inst/extdata/examples/pumps/ and re-knit.\n")
}
```

We export a PNG and store it under inst/extdata/examples/pumps/pumps_layout.png. Once exported, that PNG can be included in other documentation or compared visually to the WinBUGS reference.

The widget is not just an R visualization; it is powered by client-side JavaScript, executed directly in the user’s browser. This is a major modern capability. JavaScript is extremely fast in today’s browsers. It handles real-time dragging, force-simulation physics, and dynamic edge routing. No server interaction is needed and all layout computation happens locally. This separation lets R handle the statistical structure while JavaScript handles the interactive geometry.

This combination of R + JavaScript enables DAGnabit to provide:

  - a fully interactive graph editor

  - reproducible diagrams

  - editable layouts that can be exported and reused

The layout editor is a key component of the package, bridging computational parsing and human-driven communication.
